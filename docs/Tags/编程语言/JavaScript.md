1. 好文分享:

   市面上各大JS引擎 内存系统的设计
   https://mathiasbynens.be/notes/shapes-ics

   阅读完之后发现, 虽然 JS 可以从语法层面直接定义一个对象, 但是底层的存储设计 还是根据对象的结构 ,去设计出对应的template 来存储数据的.
   
2. V8 运行 JS 的过程

   1. 源代码(source code) 通过解析器(parser) 解析后 生成抽象语法树(AST) 

   2. 抽象语法树 通过 解释器(interpreter-Ignition) 生成了字节码(bytecode), 此字节码作为基准执行模型, 字节码等同于 25%-50% 机器码大小. 
      并且 此时抽象语法树被彻底清除掉了, 释放其内存空间.

   3. 生成后的字节码 直接被 解释器执行 (解释执行), 

   4. 在代码不断的运行过程中, 解释器收集到了很多可以优化代码的信息, 比如变量的类型, 哪些函数执行的频率较高.

   5. V8引擎的编译器(compiler-TruboFan) 会根据这些信息和字节码 来编译出经过优化的机器代码

   一些常见的优化规则:

     - 函数只是声明未被调用, 那么该函数不会生成到 AST
     - 函数如果只被调用一次, 字节码则直接被解释执行了
     - 如果函数被调用多次, 可能会被标记为热点函数, 会被编译成机器代码

   6. 随着不断执行, 会有越来越多的代码被标记为热点代码, 然后被编译成机器码.

   所以 JS 运行的过程 正是一个从解释执行到编译执行的过程.

   ![image-20201122150314021](./docs/image-20201122150314021.png)
   
3. ![image-20201122151039006](./docs/image-20201122151039006.png)

   上图的 JS 代码, 包含tc39 目前所有提案 中的特性.
   
   1. 代码片段分享:
      JS 利用 Symbol.iterator 实现遍历器
   
      ![image-20201128212044766](../../Archives/2020/11/docs/image-20201128212044766.png)
   
      为什么 ES6 要给 JS 添加诸如 Python 那样的魔法函数呢..
   
      魔法函数: 
      JS  obj[Symbol.属性]
      Python `__func__`
   
      C++ 运算符重载
      Kotlin 后缀中缀函数表达式
   
      诸如此类 可以改变默认行为的特性.. 
   
      C++ 和 Kotlin 我倒是可以想象到使用场景, 当实现内部 dsl 时很有用
   
      但 ES6 中的各种Symbol属性 提供的自定义函数, 真是多此一举了..
      我找了很多资料, 就没发现一个有意义的demo... 都是为了用而用..
   
      反正 JS 莫名其妙的设计挺多的, 也不缺这一个..
   
      ![image-20201128213106040](../../Archives/2020/11/docs/image-20201128213106040.png)
   
      ![image-20201128213109783](../../Archives/2020/11/docs/image-20201128213109783.png)
   
      JS 完全可以借助 Proxy 实现内部 DSL! 太酷了~
   
      ![image-20201128213230810](docs/image-20201128213230810.png)
   
   